################################################################################
#
#  Field constructions
#
################################################################################

doc"""
***
  NumberField(f::fmpq_poly)

>  The number field Q[x]/f generated by f.
"""
function NumberField(f::fmpq_poly; cached::Bool = true)
  return NumberField(f, "_a", cached = cached)
end

function NumberField(f::fmpz_poly, s::Symbol; cached::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), String(s), cached = cached)
end

function NumberField(f::fmpz_poly, s::AbstractString; cached::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), s, cached = cached)
end

function NumberField(f::fmpz_poly; cached::Bool = true)
  Qx, x = PolynomialRing(FlintQQ, string(parent(f).S))
  return NumberField(Qx(f), cached = cached)
end

global const number_field = NumberField

doc"""
    pure_extension(n::Int, gen::Integer) -> AnticNumberField, nf_elem
    pure_extension(n::Int, gen::fmpz) -> AnticNumberField, nf_elem

The number field with defining polynomial $x^n-gen$.
"""
function pure_extension(n::Int, gen::Integer; cached::Bool = true)
  return pure_extension(n, fmpz(gen), cached = cached)
end

function pure_extension(n::Int, gen::fmpz; cached::Bool = true)
  kx, x = FlintQQ["x"]
  return number_field(x^n - gen, cached = cached)
end

doc"""
    cyclotomic_field(n::Int) -> AnticNumberField, nf_elem

The $n$-th cyclotomic field defined by the $n$-the cyclotomic polynomial.
"""
function cyclotomic_field(n::Int; cached::Bool = true)
  Zx, x = FlintZZ["x"]
  return number_field(cyclotomic(n, x), "z_$n", cached = cached)
end

#fields with usually large class groups...
# TODO: Some sort of reference?
doc"""
    wildanger_field(n::Int, B::fmpz) -> AnticNumberField, nf_elem
    wildanger_field(n::Int, B::Integer) -> AnticNumberField, nf_elem

Returns the field with defining polynomial $x^n + \sum_{i=0}^n (-1)^iBx^i$.
These fields tend to have non-trivial class groups.
"""
function wildanger_field(n::Int, B::fmpz; cached::Bool = true)
  Qx, x = PolynomialRing(FlintQQ)
  f = x^n
  for i=0:n-1
    f += (-1)^(n-i)*B*x^i
  end
  return NumberField(f, "_\$", cached = cached)
end

function wildanger_field(n::Int, B::Integer; cached::Bool = true)
  return wildanger_field(n, fmpz(B), cached = cached)
end


################################################################################
#
#  Predicates
#
################################################################################

doc"""
    ispure_extension(K::AnticNumberField) -> Bool
    
Tests if $K$ is pure, that is, if the defining polynomial is $x^n - g$ for some
rational number $g$.
"""
function ispure_extension(K::AnticNumberField)
  if !ismonic(K.pol)
    return false
  end
  return all(i->iszero(coeff(K.pol, i)), 1:degree(K)-1)
end

doc"""
    iskummer_extension(K::AnticNumberField) -> Bool

Tests if $K$ is a Kummer extension of $\mathbb Q$, that is, if the defining
polynomial is of the form $x^2 - g$.
"""
function iskummer_extension(K::AnticNumberField)
  if degree(K) != 2
    return false
  end
  return ispure_extension(K)
end

################################################################################
#
#  Class group
#
################################################################################

doc"""
    class_group(K::AnticNumberField) -> GrpAbFinGen, Map

Shortcut for {{{class_group(maximal_order(K))}}}: returns the class
group as an abelian group and a map from this group to the set
of ideals of the maximal order.
"""
function class_group(K::AnticNumberField)
  return class_group(maximal_order(K))
end

################################################################################
#
#  Basis
#
################################################################################

doc"""
    basis(K::AnticNumberField) -> Vector{nf_elem}

Returns the power basis of $K$, that is, the elements $1,a,\dotsc,a^{d - 1}$,
where $d$ is the degree of $K$.
"""
function basis(K::AnticNumberField)
  n = degree(K)
  g = gen(K);
  d = Array{typeof(g)}(n)
  b = K(1)
  for i = 1:n-1
    d[i] = b
    b *= g
  end
  d[n] = b
  return d
end

